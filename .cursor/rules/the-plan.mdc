---
description: 
globs: 
alwaysApply: true
---
Okay, ATLAS standing by to provide a detailed Implementation Plan based on the comprehensive assessment report. This plan is designed for direct execution by an Agent-Operator (AO) or development team.

Implementation Plan: Egypt Tourism Chatbot Refinement

Mission Objective: To rectify critical architectural flaws, stabilize the codebase, implement best practices, and activate core features of the Egypt Tourism Chatbot, transitioning it from its current inadequate state (app.py) to its intended, robust src/ (FastAPI) architecture, paving the way for world-class status.

Executive Summary (Critical Path): The absolute highest priority is Phase 1. The architectural dichotomy must be resolved by eliminating the root app.py, fully activating the src/main.py (FastAPI) application, implementing the src/knowledge/knowledge_base.py placeholder to connect to the DatabaseManager and SQLite database, populating this database using scripts/populate_kb.py, and ensuring the application runs through this corrected path. Until Phase 1 is complete, the system remains fundamentally flawed and most other improvements are blocked or ineffective.

Prerequisites for AO:

Full access to the egypt-chatbot-wind-cursor Git repository.

Configured Python (3.12 recommended) development environment with Conda/Pip.

Configured Node.js/Npm environment for the frontend.

Access to necessary secrets/API keys (Anthropic, potentially others) to be placed in .env files.

Docker & Docker Compose installed locally for testing.

Access to deployment environment (Kubernetes if applicable) for later phases.

Familiarity with Python, FastAPI, React, SQLite, Redis, Docker, Git.

Phase 0: Preparation & Environment Setup (Est. Time: 0.5 - 1 day)

Task: Verify Environment Setup

Objective: Ensure local development environment matches project requirements (Python 3.12, Node, Conda env).

Key Steps:

Run conda env update --file environment.yml --prune (or equivalent based on final env setup).

Run pip install -r requirements.txt (if pip is used alongside/instead of Conda).

Verify react-frontend/ dependencies: cd react-frontend && npm install.

Install missing build/test dependencies: pip install wheel && pip install fasttext-wheel (Address known fasttext issue from docs).

Deliverable: Local environment capable of installing dependencies without critical errors.

Priority: High

Ref: ATLAS Report - Tech Debt (Dependencies), Testing

Task: Establish Configuration Baseline

Objective: Ensure required .env files exist and are populated with (at least placeholder or dev) values.

Key Steps:

Create root .env file if missing.

Populate root .env with keys for DATABASE_URI (point to sqlite:///./data/egypt_chatbot.db), SESSION_STORAGE_URI (initially point to file://./data/sessions), JWT_SECRET (generate a dev secret), ANTHROPIC_API_KEY. Add placeholders for WEATHER_API_KEY, TRANSLATION_API_KEY.

Verify/Create react-frontend/.env with necessary REACT_APP_API_URL (e.g., http://localhost:8000/api).

Review configs/services.json - ensure API keys are marked as placeholders (REPLACE_...).

Deliverable: Functional .env files allowing basic application startup (even if features are limited).

Priority: High

Ref: ATLAS Report - Arch. Assessment (Config), Tech Debt (Secrets)

Task: Baseline Test Execution

Objective: Confirm the current broken state of the test suites.

Key Steps:

Run pytest -v from the root directory. Document initial failures.

Run cd react-frontend && npm test. Document initial failures.

Deliverable: Log/report of initial test failures.

Priority: High

Ref: ATLAS Report - Tech Debt (Broken Tests), Testing

Phase 1: Core Architecture Unification & Activation (Critical Path - Est. Time: 3 - 5 days)

(Execute tasks sequentially as dependencies exist)

Task: Implement Knowledge Base Population Script

Objective: Create/Finalize and run the script to load structured data into the intended SQLite database.

Key Steps:

Review/Implement scripts/populate_kb.py. Ensure it correctly parses JSON from data/attractions, data/restaurants, data/accommodations and inserts/updates data into the SQLite DB (data/egypt_chatbot.db) using the schema defined in init_db.py. Handle en/ar fields correctly.

Ensure error handling and logging within the script.

Execute the script: python scripts/populate_kb.py.

Verify database content using a SQLite browser or CLI to confirm data loading.

Deliverable: Populated data/egypt_chatbot.db file; Successful script execution logs.

Priority: Critical (Blocker)

Ref: ATLAS Report - Arch. Assessment (KB), Tourism Domain (Gap), Tech Debt (KB Population)

Task: Implement src/knowledge/knowledge_base.py

Objective: Connect the Knowledge Base interface to the actual DatabaseManager to retrieve data from SQLite.

Key Steps:

Modify src/knowledge/knowledge_base.py.

Ensure it correctly receives the db_manager instance via constructor injection (handled by ComponentFactory).

Implement methods like get_attraction_by_id, search_attractions, search_restaurants, search_hotels, lookup_attraction, lookup_location etc., by calling the corresponding methods on the self.db_manager instance.

Translate query structures if needed between the KB interface and the DatabaseManager (e.g., handling $or, $like if used, although DatabaseManager seems to use basic dict filters). Ensure search_* methods handle both text queries and filters correctly, forming the appropriate query dict for db_manager.

Remove all mock data and placeholder return values.

Add robust logging for method calls and results/errors.

Deliverable: Functional KnowledgeBase class capable of retrieving real data from the SQLite DB via DatabaseManager.

Priority: Critical (Blocker)

Ref: ATLAS Report - Arch. Assessment (Incomplete KB), Tourism Domain (Gap)

Task: Fix Critical Test Suite Failures (Minimum Viability)

Objective: Address immediate import errors and setup issues preventing basic test execution.

Key Steps:

Examine failures reported in Phase 0, Task 3.

Fix import errors (e.g., potentially related to fasttext, sys.path issues).

Ensure basic test discovery and execution works (pytest runs and finds tests). Focus initially on unit tests for KB and DB layers.

Do not aim for full coverage yet, just unblock basic execution.

Deliverable: pytest -v runs without fatal setup/import errors, even if many tests still fail on logic.

Priority: High (Required for validation in next steps)

Ref: ATLAS Report - Tech Debt (Broken Tests)

Task: Consolidate Application Entry Point to FastAPI (src/main.py)

Objective: Make the src/ FastAPI application the primary execution target, deprecating app.py.

Key Steps:

Refactor any essential routes/logic currently only in app.py into the FastAPI structure in src/api/. Prioritize minimal essential functionality; don't migrate complex unnecessary routes yet. Ensure refactored routes utilize the Chatbot instance from the ComponentFactory.

Modify Dockerfile: Change CMD to use uvicorn src.main:app --host 0.0.0.0 --port 8000 (or the configured port). Ensure ASGI server (Uvicorn) is installed via requirements.txt. Adjust base image/build steps if needed.

Modify docker-compose.yml: Change the command for the chatbot service to align with the Uvicorn command. Update ports if necessary (e.g., map host 8000 to container 8000).

Modify start_chatbot.sh: Ensure it launches the FastAPI app via Uvicorn, not Flask/Gunicorn/app.py.

Test locally: Run docker-compose up --build. Access the API root (e.g., http://localhost:8000/) and /api/health. Check logs for FastAPI startup messages.

Deliverable: Application successfully starts using src/main.py via Uvicorn in Docker; /api/health endpoint responds correctly.

Priority: Critical (Core Architectural Fix)

Ref: ATLAS Report - Arch. Assessment (Mismatch), Tech Debt (Split)

Task: Basic End-to-End Flow Verification

Objective: Ensure the core chat flow works through the newly activated src/ path using the populated DB.

Key Steps:

Use curl, Postman, or a simple script to send a chat request to the /api/chat endpoint running via src/main.py.

Send a message that should query the KB (e.g., "Tell me about the Egyptian Museum").

Verify the response contains accurate information retrieved from the SQLite database (not mock data or generic LLM fallback). Check application logs for confirmation of DB queries via DatabaseManager.

Verify session ID persistence across requests (basic check).

Deliverable: Confirmed successful chat interaction using the src/ path and SQLite KB.

Priority: High (Validation)

Ref: ATLAS Report - Arch. Assessment (Incomplete KB), Validation

Task: Deprecate app.py

Objective: Remove the legacy Flask application to eliminate confusion and duplication.

Key Steps:

Delete the root app.py file.

Remove Flask and related direct dependencies (e.g., flask-cors, flask-swagger-ui) from requirements.txt if they are no longer needed by any FastAPI components (Werkzeug might still be needed by transitive dependencies).

Search codebase for any remaining imports or references to the root app object and remove/refactor.

Deliverable: app.py removed; requirements.txt cleaned.

Priority: Medium (Post-activation cleanup)

Ref: ATLAS Report - Code Quality (Duplicate logic)

Phase 2: Stabilization & Foundation Building (Est. Time: 5 - 8 days)

Task: Migrate Session Storage to Redis

Objective: Implement scalable and persistent session management using Redis.

Key Steps:

Ensure Redis service is running (via docker-compose up).

Update SESSION_STORAGE_URI in .env to the correct Redis URI (e.g., redis://redis:6379/0 for Docker, redis://localhost:6379/0 for local).

Thoroughly test src/utils/session.py: Ensure SessionManager correctly connects to Redis, saves session data with TTL (setex), retrieves sessions, and handles potential connection errors.

Verify session persistence across multiple API requests and after simulated application restarts (requires restarting the chatbot container while Redis persists).

Remove the file-based session storage logic from SessionManager or make Redis the definitive default.

Delete the data/sessions/ directory and its contents.

Deliverable: Sessions reliably stored and retrieved from Redis; Session file storage code removed/disabled.

Priority: High

Ref: ATLAS Report - Perf/Scale (File Sessions), DB (Confusion)

Task: Implement Real External Service Integrations

Objective: Replace mock/placeholder service implementations with functional ones.

Key Steps:

Implement src/integration/plugins/translation_service.py: Use a real translation API (e.g., Google Translate). Fetch API key securely from .env via ComponentFactory. Test translation functionality.

Review and verify src/integration/plugins/weather_service.py: Ensure it correctly calls the OpenWeatherMap API (or alternative) using the key from .env. Test weather queries.

Ensure the ServiceHub correctly routes calls to these implemented services.

Deliverable: Functional Weather and Translation services integrated via ServiceHub.

Priority: Medium

Ref: ATLAS Report - Tourism Domain (Mocks), API Integrations

Task: Consolidate Database Strategy & Fix Analytics Logging

Objective: Enforce a single, consistent strategy for database usage, particularly fixing analytics logging.

Key Steps:

Decision: Formally decide on the primary relational DB (Recommendation: SQLite unless significant scaling needs are proven early).

Refactor Analytics: Modify DatabaseManager.log_analytics_event to use only standard SQL INSERT statements compatible with the chosen primary DB (SQLite). Remove all MongoDB-specific syntax ($set, $inc). Ensure event data is stored appropriately (JSON blob recommended for flexibility).

Refactor DatabaseManager: Remove connection logic and query execution paths for the unused database (e.g., remove Postgres connection and execution blocks if SQLite is chosen). Ensure methods (get_attraction, search_attractions, etc.) consistently use the chosen DB driver/syntax.

Update init_db.py: Ensure it only creates schema for the chosen primary database. Remove schema creation for other DBs.

Update docker-compose.yml: Remove the service definition for the unused database (e.g., remove postgres service if unused).

Deliverable: Consistent database usage pattern; DatabaseManager uses only chosen DB driver/syntax; Analytics logging functions correctly.

Priority: High

Ref: ATLAS Report - DB Implementation (Inconsistency, Analytics error), Best Practices (DB Consistency)

Task: Achieve Basic Test Coverage

Objective: Write essential unit and integration tests for core components, aiming for ~50-70% coverage initially.

Key Steps:

Write unit tests for: DatabaseManager (mocking DB connections), KnowledgeBase (mocking db_manager), SessionManager (mocking Redis/File), NLUEngine (intent/entity extraction), DialogManager (state transitions).

Write basic integration tests for the /api/chat endpoint focusing on core intents (greeting, KB query). Use FastAPI's TestClient.

Fix React frontend test setup (address Jest warnings/errors) and write basic component tests.

Configure pytest.ini or pyproject.toml for coverage reporting (pytest-cov).

Integrate test execution (pytest -v --cov=src) into CI pipeline (.github/workflows/ci.yml).

Deliverable: Test suite passes consistently; Coverage reported; CI pipeline runs tests.

Priority: High

Ref: ATLAS Report - Testing (Broken/Low Coverage), Best Practices (Testing)

Task: Refine Security Configurations (FastAPI)

Objective: Implement proper security settings for the active FastAPI application.

Key Steps:

Configure CORSMiddleware in src/main.py: Set allow_origins to the specific frontend URL(s) for production (use * or dev URL for dev). Set allow_credentials=True, allow_methods=["*"], allow_headers=["*"].

JWT Authentication: Review token expiry, implement refresh token logic if necessary, ensure secure handling of JWT_SECRET from .env.

Input Validation: Ensure all API endpoints use Pydantic models for request body/parameter validation. Review models in src/models/api_models.py for completeness.

Rate Limiting: Verify fastapi-limiter integration (if kept) is functional and uses Redis backend.

Deliverable: Secure CORS, JWT, input validation, and rate limiting configurations for FastAPI.

Priority: High

Ref: ATLAS Report - Tech Debt (Insecure Config), Security (CORS, Auth, Validation), Best Practices (Security)

Phase 3: Feature Enhancement & Optimization (Est. Time: Ongoing/Iterative)

Task: Activate RAG Pipeline

Objective: Enable and test the Retrieval-Augmented Generation pipeline for improved Q&A.

Key Steps:

Implement KB content embedding: Modify scripts/populate_kb.py or create a new script to read data from SQLite, generate embeddings using the configured sentence-transformers model, and store them in the Vector DB (src/knowledge/vector_db.py). Ensure VectorDB saves to its configured path/backend.

Refine src/knowledge/rag_pipeline.py: Test retrieval logic, prompt generation for the LLM, and response synthesis.

Integrate RAG calls into the Chatbot class for relevant intents (e.g., fallback, complex queries).

Deliverable: Functional RAG pipeline providing contextually relevant answers for out-of-KB or deep queries.

Priority: Medium

Ref: ATLAS Report - Innovation (Activate RAG), Arch. Assessment (RAG/VectorDB)

Task: Implement & Integrate Monitoring

Objective: Activate and configure performance and error monitoring.

Key Steps:

Integrate src/utils/monitoring.py: Ensure Metrics, ErrorTracker (configure Sentry DSN in .env), and HealthCheck classes are correctly initialized and used within the FastAPI app lifecycle and key components (e.g., tracking request latency, errors, API call times).

Expose Prometheus metrics endpoint if using that backend.

Configure alerts based on key metrics/error rates (requires external setup - Datadog, Grafana, Sentry).

Deliverable: Basic monitoring data (latency, errors, health) being collected and potentially reported externally.

Priority: Medium

Ref: ATLAS Report - Perf/Scale (Monitoring), Best Practices (Monitoring)

Task: API Documentation (Swagger UI)

Objective: Ensure API documentation generated by FastAPI is accurate and useful.

Key Steps:

Review auto-generated docs at /api/docs.

Add descriptions, examples, and correct type hints to Pydantic models (src/models/api_models.py) and route function signatures in src/api/ to enhance documentation quality.

Deliverable: Clear and accurate API documentation accessible via Swagger UI.

Priority: Medium

Ref: ATLAS Report - Best Practices (API Design)

Task: Performance Optimization (Initial Pass)

Objective: Address obvious performance bottlenecks.

Key Steps:

Refactor key I/O-bound operations (LLM calls, external API calls via ServiceHub, potentially complex DB queries) to use FastAPI's async def and await.

Implement basic response caching using Redis (via DatabaseManager or a dedicated cache utility) for frequently requested, static data.

Review NLU embedding strategy (src/nlu/engine.py) - consider pre-loading or more efficient caching if loading is slow.

Deliverable: Key I/O operations are non-blocking; basic caching implemented.

Priority: Medium

Ref: ATLAS Report - Perf/Scale (Bottlenecks), Optimization Roadmap (Async, Caching)

Phase 4: Strategic Advancement & Differentiation (Ongoing)

Task: Implement Advanced Personalization

Task: Develop Proactive Assistance Features

Task: Integrate Multimodal Features (Images, Maps via API)

Task: Implement Dynamic Itinerary Planning

Task: Integrate Real Booking APIs

Task: Build Cultural Etiquette Engine

Task: Continuous NLU/Dialog Tuning & Evaluation

Task: Explore Vector DB Scaling / Alternatives

(Detailed steps for Phase 4 depend on specific feature choices and priorities based on business goals.)

Continuous Activities (Throughout Project)

Dependency Management: Regularly run pip-audit and npm audit. Update dependencies cautiously, testing thoroughly.

Code Review: Enforce peer reviews for all significant code changes.

Documentation: Update README.md, ARCHITECTURE.md, and code comments as changes are made.

Testing: Continuously add unit and integration tests for new features and bug fixes. Maintain/improve test coverage.

Linting: Run linters (e.g., Flake8, Black, ESLint) regularly and in CI.

AO Agent Instructions:

Prioritize Phases: Execute Phases 0 and 1 strictly sequentially. Phase 2 tasks can have some parallel execution but prioritize DB consolidation and session migration. Phase 3 onwards can be iterative.

Testing is Paramount: After every significant change in Phases 1 & 2, run the relevant tests (pytest, npm test). Ensure tests pass before proceeding or merging. Incrementally add tests as components are fixed/implemented.

Configuration via .env: Adhere strictly to using .env files (managed via ComponentFactory) for all secrets, API keys, and environment-specific variables. No hardcoding.

Commit Frequently: Use Git diligently. Make small, logical commits with clear messages referencing the task being addressed. Use branches for feature work.

Log Verification: Pay close attention to application logs during testing to verify component interactions (e.g., ensure KnowledgeBase calls DatabaseManager, which calls SQLite correctly).

Consult ATLAS Report: Refer back to the detailed sections of the ATLAS report for context on specific issues and rationale for tasks.

End of Implementation Plan.