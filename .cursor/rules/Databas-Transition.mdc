---
description: 
globs: 
alwaysApply: true
---
# Database Transition

## Current State

The Egypt Tourism Chatbot currently has a database architecture that is defined but disconnected:

1. **Active Implementation**: Hardcoded Python dictionary in `app.py`
2. **Defined Database**: SQLite defined with a populated schema
3. **Connection Issue**: The Knowledge Base component is disconnected from both the database and JSON files

## Target State

The target state is a migration from SQLite to PostgreSQL with these enhanced capabilities:

1. **PostgreSQL Database**: Scalable, production-ready database with JSONB and PostGIS
2. **Connection Pool**: Efficient database connection management
3. **Geospatial Features**: Location-based queries using PostGIS
4. **Vector Embeddings**: Semantic search using pgvector
5. **Connected Knowledge Base**: Fully functional Knowledge Base component

## Current SQLite Schema

The current SQLite schema includes these key tables:
- attractions
- cities
- accommodations
- restaurants
- transportation
- practical_info
- users
- sessions
- analytics

Key characteristics:
- Primary keys are TEXT (likely UUIDs or slugs)
- Heavy use of JSON fields for flexible data storage
- Basic foreign key relationships
- Timestamp tracking for records

## Target PostgreSQL Schema

The target PostgreSQL schema enhances the current design with:
- UUID primary keys for globally unique identifiers
- JSONB for efficient JSON storage and querying
- PostGIS geometry columns for spatial queries
- Vector columns for embedding storage
- GIN indexes for JSON fields
- Proper time zone support

## Migration Strategy

### Phase 1: Preparation
- Install PostgreSQL with PostGIS and pgvector extensions
- Create database and role with appropriate permissions
- Configure connection pooling
- Create new schema with enhanced features

### Phase 2: Data Migration
- Extract current data from SQLite and JSON files
- Transform to PostgreSQL compatible format
- Add geospatial coordinates and generate embeddings
- Load into PostgreSQL using efficient bulk loading

### Phase 3: Knowledge Base Implementation
- Implement connection pooling
- Create database abstraction layer
- Connect KnowledgeBase to DatabaseManager
- Add fallback to JSON files
- Implement query capabilities

## Performance Considerations

### Connection Pooling
- Configure appropriate pool size
- Set connection timeouts
- Implement connection recycling

### Indexing Strategy
- B-tree Indexes for standard fields
- GIN Indexes for JSONB and full-text search
- GiST Indexes for PostGIS geometry columns
- Vector Indexes for similarity search

### Query Optimization
- JSONB Path Queries for nested JSON
- Spatial Queries for proximity search
- Vector Similarity for semantic search

## Monitoring and Maintenance

- Implement regular database health checks
- Create automated backup strategy
- Monitor query performance
- Implement database maintenance procedures