# DEPRECATED: All database logic has migrated to PostgreSQL.
# This file is retained only for legacy reference and should not be used.
# See postgres_database.py for the current implementation.
        """
        Initialize the database manager.
        
        Args:
            database_uri: URI of the SQLite database
        """
        # Use provided URI or get from environment
        self.database_uri = database_uri or os.environ.get(
            "DATABASE_URI", "sqlite:///./data/egypt_chatbot.db"
        )
        
        # Extract the file path from the URI
        if self.database_uri.startswith("sqlite:///"):
            self.db_path = self.database_uri.replace("sqlite:///", "")
        else:
            self.db_path = self.database_uri
        
        self.connection = None
        self.db_type = "sqlite"
        logger.info(f"DatabaseManager initialized with {self.db_type}")
    
    def connect(self) -> None:
        """
        Connect to the database.
        
        This method establishes a connection to the SQLite database.
        """
        try:
            # Ensure the directory exists
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            
            # Connect to the database
            self.connection = sqlite3.connect(self.db_path)
            
            # Configure the connection
            self.connection.row_factory = sqlite3.Row
            
            # Enable foreign key constraints
            self.connection.execute("PRAGMA foreign_keys = ON")
            
            logger.info(f"Connected to SQLite database: {self.db_path}")
        except Exception as e:
            logger.error(f"Error connecting to database: {str(e)}")
            raise
    
    def disconnect(self) -> None:
        """
        Disconnect from the database.
        
        This method closes the connection to the SQLite database.
        """
        if self.connection:
            self.connection.close()
            self.connection = None
            logger.info("Disconnected from SQLite database")
    
    def get_connection(self) -> sqlite3.Connection:
        """
        Get a database connection.
        
        This method returns an existing connection or creates a new one.
        
        Returns:
            SQLite connection
        """
        if not self.connection:
            self.connect()
        return self.connection
    
    def execute_query(
        self, query: str, params: tuple = None
    ) -> List[Dict[str, Any]]:
        """
        Execute a SQLite query and return the results.
        
        Args:
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            List of dictionaries representing the query results
        """
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            # Execute the query
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            # Fetch results
            results = [dict(row) for row in cursor.fetchall()]
            
            return results
        except Exception as e:
            logger.error(f"Error executing query: {str(e)}")
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            raise
    
    def execute_update(
        self, query: str, params: tuple = None
    ) -> int:
        """
        Execute a SQLite update/insert/delete and return the row count.
        
        Args:
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            Number of rows affected
        """
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            # Execute the query
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            # Commit the changes
            conn.commit()
            
            # Return row count
            return cursor.rowcount
        except Exception as e:
            logger.error(f"Error executing update: {str(e)}")
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            raise
    
    def get_attraction_by_id(self, attraction_id: str) -> Optional[Dict[str, Any]]:
        """
        Get an attraction by its ID.
        
        Args:
            attraction_id: Attraction ID
            
        Returns:
            Attraction data as a dictionary, or None if not found
        """
        query = "SELECT * FROM attractions WHERE id = ?"
        params = (attraction_id,)
        
        results = self.execute_query(query, params)
        
        if results:
            attraction = results[0]
            
            # Parse the JSON data field if it exists
            if "data" in attraction and attraction["data"]:
                try:
                    attraction["data"] = json.loads(attraction["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in attraction {attraction_id}")
            
            return attraction
        
        return None
    
    def search_attractions(
        self, filters: Dict[str, Any], limit: int = 10, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Search for attractions based on filters.
        
        Args:
            filters: Dictionary of search filters
            limit: Maximum number of results
            offset: Result offset for pagination
            
        Returns:
            List of attractions matching the filters
        """
        # Build the query
        query = "SELECT * FROM attractions WHERE 1=1"
        params = []
        
        # Add filters to the query
        if "name" in filters:
            query += " AND (json_extract(name, '$.en') LIKE ? OR json_extract(name, '$.ar') LIKE ?)"
            params.extend([f"%{filters['name']}%", f"%{filters['name']}%"])
        
        if "city_id" in filters:
            query += " AND city_id = ?"
            params.append(filters["city_id"])
        
        if "type_id" in filters:
            query += " AND type_id = ?"
            params.append(filters["type_id"])
        
        # Add limit and offset
        query += " LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute the query
        results = self.execute_query(query, tuple(params))
        
        # Parse JSON data fields
        for attraction in results:
            if "data" in attraction and attraction["data"]:
                try:
                    attraction["data"] = json.loads(attraction["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in attraction {attraction.get('id')}")
        
        return results
    
    def get_city_by_id(self, city_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a city by its ID.
        
        Args:
            city_id: City ID
            
        Returns:
            City data as a dictionary, or None if not found
        """
        query = "SELECT * FROM cities WHERE id = ?"
        params = (city_id,)
        
        results = self.execute_query(query, params)
        
        if results:
            city = results[0]
            
            # Parse the JSON data field if it exists
            if "data" in city and city["data"]:
                try:
                    city["data"] = json.loads(city["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in city {city_id}")
            
            return city
        
        return None
    
    def search_cities(
        self, filters: Dict[str, Any], limit: int = 10, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Search for cities based on filters.
        
        Args:
            filters: Dictionary of search filters
            limit: Maximum number of results
            offset: Result offset for pagination
            
        Returns:
            List of cities matching the filters
        """
        # Build the query
        query = "SELECT * FROM cities WHERE 1=1"
        params = []
        
        # Add filters to the query
        if "name" in filters:
            query += " AND (json_extract(name, '$.en') LIKE ? OR json_extract(name, '$.ar') LIKE ?)"
            params.extend([f"%{filters['name']}%", f"%{filters['name']}%"])
        
        if "region_id" in filters:
            query += " AND region_id = ?"
            params.append(filters["region_id"])
        
        # Add limit and offset
        query += " LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute the query
        results = self.execute_query(query, tuple(params))
        
        # Parse JSON data fields
        for city in results:
            if "data" in city and city["data"]:
                try:
                    city["data"] = json.loads(city["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in city {city.get('id')}")
        
        return results
    
    def get_hotel_by_id(self, hotel_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a hotel by its ID.
        
        Args:
            hotel_id: Hotel ID
            
        Returns:
            Hotel data as a dictionary, or None if not found
        """
        query = "SELECT * FROM accommodations WHERE id = ? AND type = 'hotel'"
        params = (hotel_id,)
        
        results = self.execute_query(query, params)
        
        if results:
            hotel = results[0]
            
            # Parse the JSON data field if it exists
            if "data" in hotel and hotel["data"]:
                try:
                    hotel["data"] = json.loads(hotel["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in hotel {hotel_id}")
            
            return hotel
        
        return None
    
    def search_hotels(
        self, filters: Dict[str, Any], limit: int = 10, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Search for hotels based on filters.
        
        Args:
            filters: Dictionary of search filters
            limit: Maximum number of results
            offset: Result offset for pagination
            
        Returns:
            List of hotels matching the filters
        """
        # Build the query
        query = "SELECT * FROM hotels WHERE 1=1"
        params = []
        
        # Add filters to the query
        if "name" in filters:
            query += " AND (json_extract(name, '$.en') LIKE ? OR json_extract(name, '$.ar') LIKE ?)"
            params.extend([f"%{filters['name']}%", f"%{filters['name']}%"])
        
        if "city_id" in filters:
            query += " AND city_id = ?"
            params.append(filters["city_id"])
        
        if "type_id" in filters:
            query += " AND type_id = ?"
            params.append(filters["type_id"])
        
        if "stars" in filters:
            query += " AND stars >= ?"
            params.append(filters["stars"])
        
        # Add limit and offset
        query += " LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute the query
        results = self.execute_query(query, tuple(params))
        
        # Parse JSON data fields
        for hotel in results:
            if "data" in hotel and hotel["data"]:
                try:
                    hotel["data"] = json.loads(hotel["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in hotel {hotel.get('id')}")
        
        return results
    
    def get_restaurant_by_id(self, restaurant_id: str) -> Optional[Dict[str, Any]]:
        """
        Get a restaurant by its ID.
        
        Args:
            restaurant_id: Restaurant ID
            
        Returns:
            Restaurant data as a dictionary, or None if not found
        """
        query = "SELECT * FROM restaurants WHERE id = ?"
        params = (restaurant_id,)
        
        results = self.execute_query(query, params)
        
        if results:
            restaurant = results[0]
            
            # Parse the JSON data field if it exists
            if "data" in restaurant and restaurant["data"]:
                try:
                    restaurant["data"] = json.loads(restaurant["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in restaurant {restaurant_id}")
            
            return restaurant
        
        return None
    
    def search_restaurants(
        self, filters: Dict[str, Any], limit: int = 10, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Search for restaurants based on filters.
        
        Args:
            filters: Dictionary of search filters
            limit: Maximum number of results
            offset: Result offset for pagination
            
        Returns:
            List of restaurants matching the filters
        """
        # Build the query
        query = "SELECT * FROM restaurants WHERE 1=1"
        params = []
        
        # Add filters to the query
        if "name" in filters:
            query += " AND (json_extract(name, '$.en') LIKE ? OR json_extract(name, '$.ar') LIKE ?)"
            params.extend([f"%{filters['name']}%", f"%{filters['name']}%"])
        
        if "city_id" in filters:
            query += " AND city_id = ?"
            params.append(filters["city_id"])
        
        if "cuisine_id" in filters:
            query += " AND cuisine_id = ?"
            params.append(filters["cuisine_id"])
        
        # Add limit and offset
        query += " LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute the query
        results = self.execute_query(query, tuple(params))
        
        # Parse JSON data fields
        for restaurant in results:
            if "data" in restaurant and restaurant["data"]:
                try:
                    restaurant["data"] = json.loads(restaurant["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in restaurant {restaurant.get('id')}")
        
        return results
    
    def get_practical_info(self, info_id: str) -> Optional[Dict[str, Any]]:
        """
        Get practical information by its ID.
        
        Args:
            info_id: Practical information ID
            
        Returns:
            Practical information data as a dictionary, or None if not found
        """
        query = "SELECT * FROM practical_info WHERE id = ?"
        params = (info_id,)
        
        results = self.execute_query(query, params)
        
        if results:
            info = results[0]
            
            # Parse the JSON data field if it exists
            if "data" in info and info["data"]:
                try:
                    info["data"] = json.loads(info["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in practical_info {info_id}")
            
            return info
        
        return None
    
    def search_practical_info(
        self, filters: Dict[str, Any], limit: int = 10, offset: int = 0
    ) -> List[Dict[str, Any]]:
        """
        Search for practical information based on filters.
        
        Args:
            filters: Dictionary of search filters
            limit: Maximum number of results
            offset: Result offset for pagination
            
        Returns:
            List of practical information matching the filters
        """
        # Build the query
        query = "SELECT * FROM practical_info WHERE 1=1"
        params = []
        
        # Add filters to the query
        if "category" in filters:
            query += " AND category = ?"
            params.append(filters["category"])
        
        if "keyword" in filters:
            query += " AND (title_en LIKE ? OR title_ar LIKE ? OR content_en LIKE ? OR content_ar LIKE ?)"
            keyword = f"%{filters['keyword']}%"
            params.extend([keyword, keyword, keyword, keyword])
        
        # Add limit and offset
        query += " LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        
        # Execute the query
        results = self.execute_query(query, tuple(params))
        
        # Parse JSON data fields
        for info in results:
            if "data" in info and info["data"]:
                try:
                    info["data"] = json.loads(info["data"])
                except json.JSONDecodeError:
                    logger.warning(f"Invalid JSON in practical_info {info.get('id')}")
        
        return results
    
    def log_analytics_event(
        self, event_type: str, event_data: Dict[str, Any], session_id: str = None, user_id: str = None
    ) -> bool:
        """
        Log an analytics event to the database.
        
        Args:
            event_type: Type of event
            event_data: Event data to log
            session_id: Session ID
            user_id: User ID
            
        Returns:
            True if the event was logged successfully, False otherwise
        """
        try:
            query = """
                INSERT INTO analytics (
                    event_type, 
                    event_data, 
                    session_id, 
                    user_id, 
                    timestamp
                ) VALUES (?, ?, ?, ?, datetime('now'))
            """
            
            params = (
                event_type,
                json.dumps(event_data),
                session_id,
                user_id
            )
            
            self.execute_update(query, params)
            return True
        except Exception as e:
            logger.error(f"Error logging analytics event: {str(e)}")
            return False
    
    def get_analytics_events(
        self, filters: Dict[str, Any] = None, limit: int = 100, offset: int = 0,
        sort_by: str = "timestamp", sort_dir: int = -1
    ) -> List[Dict[str, Any]]:
        """
        Retrieve analytics events from the database based on filters.
        
        Args:
            filters: Dictionary of filters to apply to the query
            limit: Maximum number of events to return
            offset: Number of events to skip (for pagination)
            sort_by: Field to sort by (default: timestamp)
            sort_dir: Sort direction: 1 for ascending, -1 for descending (default: -1)
            
        Returns:
            List of analytics events matching the filters
        """
        try:
            query_parts = ["SELECT id, event_type, event_data, session_id, user_id, timestamp FROM analytics"]
            params = []
            
            # Apply filters if provided
            if filters:
                where_clauses = []
                
                if 'event_type' in filters:
                    where_clauses.append("event_type = ?")
                    params.append(filters['event_type'])
                
                if 'session_id' in filters:
                    where_clauses.append("session_id = ?")
                    params.append(filters['session_id'])
                
                if 'user_id' in filters:
                    where_clauses.append("user_id = ?")
                    params.append(filters['user_id'])
                
                if 'timestamp_gte' in filters:
                    where_clauses.append("timestamp >= ?")
                    params.append(filters['timestamp_gte'])
                
                if 'timestamp_lt' in filters:
                    where_clauses.append("timestamp < ?")
                    params.append(filters['timestamp_lt'])
                
                if where_clauses:
                    query_parts.append("WHERE " + " AND ".join(where_clauses))
            
            # Apply sorting
            direction = "ASC" if sort_dir > 0 else "DESC"
            query_parts.append(f"ORDER BY {sort_by} {direction}")
            
            # Apply limit and offset
            query_parts.append(f"LIMIT ? OFFSET ?")
            params.extend([limit, offset])
            
            # Execute query
            events = self.execute_query(" ".join(query_parts), tuple(params))
            
            # Parse event_data JSON
            for event in events:
                if 'event_data' in event and event['event_data']:
                    try:
                        event['event_data'] = json.loads(event['event_data'])
                    except json.JSONDecodeError:
                        logger.warning(f"Failed to parse event_data JSON for event ID: {event.get('id')}")
            
            return events
        except Exception as e:
            logger.error(f"Error retrieving analytics events: {str(e)}")
            return []
    
    def get_user_by_username(self, username: str) -> Optional[Dict[str, Any]]:
        """
        Get a user by username.
        
        Args:
            username: The username to search for
            
        Returns:
            User information as a dictionary or None if user not found
        """
        try:
            query = "SELECT * FROM users WHERE username = ?"
            params = (username,)
            
            results = self.execute_query(query, params)
            
            if results and len(results) > 0:
                user = results[0]
                
                # Parse the JSON data field if it exists
                if "data" in user and user["data"]:
                    try:
                        user["data"] = json.loads(user["data"])
                    except json.JSONDecodeError:
                        logger.warning(f"Invalid JSON in user data for {username}")
                        user["data"] = {}
                else:
                    user["data"] = {}
                    
                return user
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting user by username '{username}': {str(e)}")
            return None
    
    def save_user(self, user: Dict[str, Any]) -> bool:
        """
        Save a user to the database. This creates a new user or updates an existing one.
        
        Args:
            user: User information dictionary containing at minimum id, username, 
                 password_hash, salt, and role
                 
        Returns:
            True if the operation was successful, False otherwise
        """
        try:
            # Check if user already exists
            existing_user = None
            if "id" in user:
                query = "SELECT id FROM users WHERE id = ?"
                params = (user["id"],)
                results = self.execute_query(query, params)
                if results and len(results) > 0:
                    existing_user = results[0]
            
            # Handle data field if present
            if "data" in user and isinstance(user["data"], dict):
                user_data = json.dumps(user["data"])
            else:
                user_data = json.dumps({})
                
            if existing_user:
                # Update existing user
                query = """
                    UPDATE users SET 
                        username = ?,
                        email = ?,
                        password_hash = ?,
                        salt = ?,
                        role = ?,
                        data = ?,
                        updated_at = datetime('now')
                    WHERE id = ?
                """
                
                params = (
                    user["username"],
                    user.get("email"),
                    user["password_hash"],
                    user["salt"],
                    user.get("role", "user"),
                    user_data,
                    user["id"]
                )
            else:
                # Insert new user
                query = """
                    INSERT INTO users (
                        id,
                        username,
                        email,
                        password_hash,
                        salt,
                        role,
                        data,
                        created_at,
                        updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
                """
                
                params = (
                    user["id"],
                    user["username"],
                    user.get("email"),
                    user["password_hash"],
                    user["salt"],
                    user.get("role", "user"),
                    user_data
                )
            
            self.execute_update(query, params)
            logger.info(f"User '{user['username']}' saved successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error saving user: {str(e)}")
            return False 